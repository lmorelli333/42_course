This project is a training to multi-threads programming with the use of mutex.


Un thread, in informatica, è la più piccola sequenza di istruzioni eseguibile da un processore. È un flusso di esecuzione all'interno di un processo e condivide con gli altri thread dello stesso processo lo spazio di indirizzamento, i file aperti e altre risorse associate al processo. In altre parole, un thread rappresenta un "sotto-processo" che opera all'interno di un processo principale. I thread sono utilizzati per eseguire operazioni concorrenti o parallele all'interno di un'applicazione. Senza una corretta sincronizzazione, l'accesso concorrente ai dati può portare a problemi come la race condition e la corruzione dei dati. Pertanto, è necessario utilizzare strutture di sincronizzazione come mutex, semafori o variabili condizionali per garantire che i thread possano cooperare in modo sicuro ed efficiente.

Un mutex (acronimo di "mutual exclusion") è un meccanismo di sincronizzazione utilizzato per garantire che solo un thread alla volta possa accedere a una risorsa condivisa evitando così problemi di concorrenza e conflitti di accesso.

La funzione pthread_create viene utilizzata per creare un nuovo thread e viene dichiarata cosí: int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg); -thread: puntatore a una variabile di tipo pthread_t che conterrà l'identificatore univoco del nuovo thread creato. -attr: puntatore agli attributi del thread. Di solito, puoi passare NULL per usare gli attributi predefiniti. -start_routine: puntatore a una funzione che rappresenta il punto di ingresso del nuovo thread. -arg: argomento da passare alla funzione start_routine. La funzione restituisce 0 se la creazione del thread ha avuto successo, altrimenti restituisce un codice di errore.

La funzione pthread_join viene utilizzata per attendere che un thread termini la sua esecuzione e viene dichiarata cosí: int pthread_join(pthread_t thread, void **retval); -thread: l'identificatore del thread che si desidera attendere. -retval: puntatore a un puntatore che conterrà il valore restituito dal thread alla sua uscita. Puoi passare NULL se non ti interessa il valore restituito. La funzione restituisce 0 se ha avuto successo, altrimenti restituisce un codice di errore. In pratica viene utilizzata per sincronizzare il flusso principale del programma con l'esecuzione del thread creato, attendendo che il thread termini prima di procedere oltre.

La funzione init_general è responsabile per l'inizializzazione della struttura t_general. La funzione prende in input un puntatore a una struttura t_general, argc e argv. La funzione assegna ai campi della struttura general i valori corrispondenti agli argomenti forniti in input. Per fare ciò, utilizza la funzione ft_atoi per convertire le stringhe contenute in argv in int o in u_int64_t. general->philo_nb viene inizializzato con il numero di filosofi passato come primo argomento, general->time_to_die con il tempo in ms prima che un filosofo muoia senza mangiare, general->time_to_eat con il tempo in ms in cui un filosofo mangia. Se viene fornito un sesto argomento (di default inizializzato a -1), la funzione inizializza general->meals_nb che rappresenta il numero minimo di pasti che ciascun filosofo deve consumare dopo il quale il programma si interrompe. La funzione esegue alcune verifiche sugli input forniti. Se una delle condizioni non viene soddisfatta, la funzione restituisce un errore utilizzando la funzione error e termina l'inizializzazione. Vengono inizializzati altri campi della struttura general con valori iniziali: general->start_time viene impostato al valore del tempo di sistema ottenuto tramite get_time(), che rappresenta il momento iniziale del programma; general->dead_flag e general->full_belly vengono impostati inizialmente a 0, e servono per indicare se il filosofo è morto o se il programma è terminato. La funzione inizializza due mutex utilizzati per la sincronizzazione dei thread: general->lock: viene utilizzato per proteggere l'accesso concorrente alle risorse condivise tra i thread, come le forchette o altri dati critici. general->output: é utilizzato per sincronizzare l'output dei messaggi stampati, in modo che i messaggi non si sovrappongano durante l'esecuzione. Alla fine, la funzione restituisce 0, indicando che l'inizializzazione è stata completata con successo.

La funzione init_forks è responsabile dell'inizializzazione delle forchette che rappresentano le risorse condivise tra i filosofi. Viene eseguito un ciclo while per inizializzare ogni forchetta. Il ciclo scorre da 0 a general->philo_nb - 1. Per ciascun valore i nel ciclo, la funzione utilizza la chiamata a pthread_mutex_init per inizializzare il mutex associato alla forchetta corrispondente nella struttura general->forks. Dopo l'inizializzazione delle forchette, la funzione passa a inizializzare i puntatori alle forchette per ciascun filosofo. Ogni filosofo ha un puntatore alla forchetta a sinistra e un puntatore alla forchetta a destra. La forchetta a sinistra del primo filosofo (general->philos[0]) viene impostata come il puntatore alla forchetta iniziale nell'array general->forks[0], e la forchetta a destra viene impostata come il puntatore alla forchetta finale nell'array general->forks[general->philo_nb - 1]. Questo collega la forchetta del primo filosofo con l'ultima forchetta, creando una disposizione circolare attorno al tavolo. Successivamente, la funzione esegue un altro ciclo while per inizializzare i puntatori delle forchette per gli altri filosofi. Inizia da i = 1, poiché abbiamo già inizializzato il primo filosofo al passo precedente. Per ciascun valore i nel ciclo, la forchetta a sinistra viene impostata come il puntatore alla forchetta corrispondente nell'array general->forks[i], e la forchetta a destra viene impostata come il puntatore alla forchetta nell'array general->forks[i - 1]. Questo collega ogni filosofo alla forchetta a sinistra e a quella a destra, completando la disposizione circolare delle forchette. Alla fine, la funzione restituisce 0, indicando che l'inizializzazione delle forchette è stata completata con successo. In sostanza, la funzione init_forks inizializza i mutex per ciascuna forchetta e assegna i puntatori delle forchette ai filosofi in modo che possano accedere alle forchette corrette durante la simulazione.

La funzione init_philos è responsabile per l'inizializzazione dei dati relativi a ciascun filosofo nell'array philos all'interno della struttura t_general. Questa contiene info generali utilizzate nel progetto, e philos è un array di strutture t_philo, dove ciascuna struttura rappresenta un filosofo. Viene eseguito un ciclo while che scorre da 0 a general->philo_nb - 1. Per ogni filosofo, vengono impostati i seguenti valori: general->philos[i].general: viene impostato come un puntatore alla struttura t_general, consentendo al filosofo di accedere alle info generali condivise tra i filosofi, come il numero totale di filosofi, i tempi, ecc; general->philos[i].position: viene impostata la posizione del filosofo, che è un numero intero univoco, in questo caso, rappresentato come i + 1; general->philos[i].eat_time: viene impostato come general->start_time, che rappresenta il momento iniziale del programma, indicando l'ultimo momento in cui il filosofo ha mangiato; general->philos[i].meals_counter: viene impostato a 0, e rappresenta il numero di pasti consumati finora dal filosofo; general->philos[i].eating_flag: viene impostato a 0, rappresentando se il filosofo sta mangiando al momento dell'inizializzazione (0 indica che il filosofo non sta mangiando al momento); general->philos[i].death_time: viene impostato come general->time_to_die, che rappresenta il tempo in ms prima che il filosofo muoia senza mangiare; general->philos[i].max_meals: viene impostato come general->meals_nb, che rappresenta il numero massimo di pasti che il filosofo può consumare. Se meals_nb è stato inizializzato a -1 (ovvero non fornito come argomento) non c'è limite al numero di pasti. Viene inizializzato un mutex general->philos[i].lock associato a ciascun filosofo, utilizzato per proteggere l'accesso concorrente a risorse condivise all'interno della struttura t_philo. Alla fine, la funzione inizializza tutti i filosofi presenti nell'array general->philos con i dati e le impostazioni iniziali. In sintesi, la funzione init_philos prepara e inizializza tutti i dati relativi a ciascun filosofo, impostando valori iniziali come la posizione, time di inizio dei pasti, contatori, ecc.

La funzione one_philo gestisce il caso in cui è presente solo un filosofo. Imposta general->start_time con il valore di tempo iniziale del programma. Viene utilizzata pthread_create per creare un nuovo thread (che rappresenta il filosofo) che eseguirà la funzione action. Il primo argomento di pthread_create è un puntatore a una variabile di tipo pthread_t, in cui verrà salvato l'identificatore del nuovo thread. Il secondo argomento è NULL, indicando che vengono utilizzati gli attributi di default per il thread. Il terzo argomento è un puntatore alla funzione action, che rappresenta il comportamento del filosofo. Il quarto argomento è un puntatore alla struttura general->philos[0], che contiene i dati relativi al filosofo. Dopo aver creato il thread, viene utilizzata la funzione pthread_detach per indicare che il thread può essere terminato liberamente al termine della sua esecuzione. Questo evita la necessità di un'ulteriore chiamata a pthread_join per attendere la terminazione del thread. Viene avviato un ciclo while che continuerà finché general->dead_flag è uguale a 0. Questo ciclo serve a mantenere il programma in esecuzione finché il filosofo non muore. All'interno del ciclo, la funzione ft_usleep viene chiamata con un argomento di 0. Questa è un'approssimazione di un ritardo molto breve, e la funzione è stata progettata per mettere in pausa l'esecuzione del thread per un breve periodo di tempo, consentendo ad altri thread o processi di eseguire le loro operazioni. Una volta che il filosofo muore (cioè general->dead_flag diventa 1), la funzione destroy_and_free viene chiamata per terminare il programma e liberare la memoria. Infine, la funzione restituisce 0 per indicare che tutto é stato gestito correttamente.

La funzione create_threads è responsabile per l'inizializzazione e la gestione dei thread. Viene eseguito un controllo per verificare se general->meals_nb è maggiore di 0. Se è maggiore di 0, significa che è stato fornito un numero massimo di pasti come argomento del programma. In questo caso, viene creato un thread aggiuntivo per il monitoraggio del numero di pasti consumati dai filosofi. Se data->meals_nb è maggiore di 0 ma il thread per il monitoring non può essere creato con pthread_create, la funzione restituisce un errore utilizzando la funzione error e termina l'esecuzione. Dopo viene eseguito un ciclo while per creare i thread per ciascun filosofo presente nel sistema. Per ciascun valore di i, la funzione utilizza pthread_create per creare un nuovo thread che eseguirà la funzione actions. Il primo argomento di pthread_create è un puntatore a una variabile di tipo pthread_t, in cui verrà salvato l'identificatore del nuovo thread. Il secondo argomento di pthread_create è NULL, indicando che vengono utilizzati gli attributi di default per il thread. Il terzo argomento è un puntatore alla funzione actions, che rappresenta il comportamento del filosofo. Il quarto argomento è un puntatore alla struttura general->philos[i], che contiene i dati relativi al filosofo corrente. Dopo aver creato un thread per un filosofo, la funzione esegue una breve pausa con ft_usleep(1). Questa pausa serve a garantire che il thread successivo non venga creato troppo velocemente e permette ai thread di stabilirsi correttamente prima che venga creato il successivo. Una volta che tutti i thread sono stati creati, la funzione esegue un altro ciclo while per aspettare che tutti i thread completino la loro esecuzione. La funzione pthread_join viene utilizzata per attendere la terminazione di ciascun thread. pthread_join prende in input un thread ID (general->thread[i]) e un puntatore a un puntatore (che qui viene impostato a NULL). Se pthread_join restituisce un valore diverso da 0, significa che si è verificato un errore durante la "join" del thread, quindi la funzione restituisce un errore e termina l'esecuzione. Infine, una volta che tutti i thread hanno terminato l'esecuzione, la funzione restituisce 0 per indicare che l'inizializzazione e l'esecuzione dei thread sono state completate correttamente. In sintesi, la funzione create_threads gestisce l'inizializzazione e l'esecuzione dei thread, incluso il thread del monitoring se è stato specificato un numero massimo di pasti. La funzione si assicura che tutti i thread vengano creati correttamente e che siano terminati prima di restituire il controllo.

La funzione output_message è utilizzata per stampare i messaggi relativi all'attività dei filosofi. I messaggi includono informazioni come il tempo trascorso dall'inizio del programma, la posizione del filosofo coinvolto e l'azione che sta compiendo. La funzione prende due argomenti: un puntatore a una stringa str che rappresenta il messaggio da stampare, e un puntatore a una struttura t_philo chiamata philo che contiene i dati relativi al filosofo coinvolto nel messaggio. All'inizio della funzione, viene acquisito un lock utilizzando il mutex philo->general->output. Questo è un meccanismo di sincronizzazione per garantire che i messaggi vengano stampati in modo coerente senza sovrapporsi, soprattutto quando più filosofi stampano contemporaneamente. Viene calcolato il tempo trascorso dall'inizio del programma utilizzando get_time() e sottraendo start_time dal risultato. Questo valore rappresenta il tempo trascorso in ms. Viene eseguito un controllo condizionale per verificare se il messaggio è "died" e se dead_flag è uguale a 0. Se il messaggio è "died" e dead_flag è ancora uguale a 0, significa che il filosofo sta morendo per la prima volta. In questo caso, il messaggio viene stampato con la posizione del filosofo e il tempo trascorso, e dead_flag viene impostata a 1 per indicare che il filosofo è morto. Se non è morto, il messaggio viene stampato con la posizione del filosofo e il tempo trascorso. Dopo aver stampato il messaggio, il lock viene rilasciato con pthread_mutex_unlock, consentendo ad altri filosofi di stampare i messaggi in modo sincronizzato.

La funzione actions è il punto centrale di ogni thread di filosofo: inizia creando un nuovo thread per eseguire la funzione monitoring in un thread separato che è responsabile di controllare se il filosofo muore di fame e se ha raggiunto il numero massimo di pasti consentiti. Il ciclo while si ripete finché il flag dead_flag è uguale a 0. All'interno del ciclo, la funzione eat_sleep_think viene chiamata e rappresenta il comportamento di mangiare, dormire e pensare del filosofo. Se il filosofo muore, il thread di actions aspetta che il thread di monitoring termini usando pthread_join. In sintesi, la funzione actions coordina il comportamento generale del filosofo, chiamando la funzione eat_sleep_think e garantendo che il thread di monitoring sia eseguito in modo separato per monitorare lo stato del filosofo.

La funzione eat_sleep_think rappresenta il comportamento del filosofo quando sta mangiando, dormendo e pensando. Acquisisce prima il lock della forchetta a destra (philo->right_fork) e poi il lock della forchetta a sinistra (philo->left_fork). Questo garantisce che il filosofo prenda le forchette in modo sicuro evitando situazioni di deadlock. Dopo aver acquisito entrambe le forchette, il filosofo imposta philo->eating_flag a 1 per indicare che sta mangiando. Registra il tempo corrente (get_time()) in philo->eat_time, che viene utilizzato per controllare se il filosofo muore di fame. Il contatore dei pasti del filosofo (meals_counter) viene incrementato. Il filosofo attende per il tempo specificato in philo->general->time_to_eat utilizzando la funzione ft_usleep. Durante questo periodo il filosofo mangia. Dopo aver finito di mangiare, il filosofo imposta philo->eating_flag a 0 per indicare che non sta mangiando più e rilascia il lock del mutex philo->lock. Successivamente, il filosofo rilascia le due forchette e i rispettivi lock. Poi il filosofo attende per il tempo specificato in philo->general->time_to_sleep utilizzando la funzione ft_usleep, per simulare il periodo di sonno. Infine pensa.

La funzione monitoring è un thread separato creato per monitorare lo stato di un filosofo. Il suo compito è controllare se il filosofo muore di fame e se ha raggiunto il numero massimo di pasti consentiti. philo_ptr è il puntatore al filosofo che la funzione dovrà monitorare. Il ciclo while si ripete finché dead_flag è uguale a 0, il che significa che nessun filosofo è morto. All'interno del ciclo, il thread di monitoring acquisisce il lock del mutex philo->lock, che è il mutex associato a questo filosofo. La funzione controlla se il tempo trascorso da quando il filosofo ha iniziato a mangiare (philo->eat_time) è maggiore o uguale al tempo massimo consentito per mangiare senza morire di fame (philo->death_time). Se questa condizione è vera e il filosofo non sta mangiando (quindi eating_flag è 0), viene chiamata la funzione output_message con il messaggio "died", che indica che il filosofo è morto di fame. La funzione controlla anche se il numero di pasti consumati dal filosofo (philo->meals_counter) è uguale al numero massimo di pasti consentiti (philo->general->meals_nb). Se questa condizione è vera, il thread di monitoring acquisisce anche il lock del mutex philo->general->lock, che è un mutex globale utilizzato per contare quanti filosofi hanno mangiato abbastanza pasti. Il contatore general->full_belly viene incrementato e il contatore di pasti del filosofo viene incrementato. Infine, il thread di monitoring rilascia il lock del mutex philo->general->lock. In sintesi, la funzione monitoring è responsabile di controllare lo stato del filosofo per assicurarsi che non muoia di fame e che non superi il numero massimo di pasti consentiti.
